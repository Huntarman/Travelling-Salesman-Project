#include <iostream>
#include "fstream"
#include "Graph/Graph.h"
#include "GraphComponents/Edge.h"
#include "GraphComponents/Vortex.h"
#include <Windows.h>
#include <random>

using std::cout;
void createFile(int vortexAmount);
void TSP();
void StartCounter(int n);
double GetCounter();
void tests();
long long CounterStart = 0;
double PCFreq = 0.0;
std::string jednostka_czasu;

std::random_device rand_dev2;
std::mt19937 generatorMain(rand_dev2());
std::uniform_int_distribution<int> distributionMain(1, 100);

int main() {
    while(true){
        cout<<"___MENU___\n";
        cout<<"1 - ENTER TSP MENU\n";
        cout<<"2 - GENERATE FILE\n";
        cout<<"3 - EXIT\n";
        cout<<"Input: ";
        int a;
        std::cin>>a;
        getchar();
        system("cls");
        switch (a) {
            case 1:
                TSP();
                system("cls");
                break;

            case 2:
                cout<<"NOTE: The graph that would be created from the file generated by this function\n";
                cout<<"It will always be full and asymmetric!\n";
                cout<<"It will be represented as adjacency matrix in the file\n";
                int b;
                cout<<"How many vortices: ";
                std::cin>>b;
                createFile(b);
                break;

            case 3:
                exit(0);

            default:
                cout<<"Wrong Input!\n";
                getchar();
                getchar();
                system("cls");
                break;
        }
    }
}

void TSP(){
    int a = 0;
    Graph graph;
    for (;;) {
        graph.printTSP();
        cout<<"\n0 - QUIT\n";
        cout<<"1 - BRUTE FORCE\n";
        cout<<"2 - DYNAMIC PROGRAMMING\n";
        cout<<"3 - Add vortices\n";
        cout<<"4 - Add edge\n";
        cout<<"5 - Fill Graph with random edges\n";
        cout<<"6 - Read graph from .txt file\n";
        cout<<"7 - Wyswietl macierz sasiedztwa\n";
        cout<<"8 - Wyswietl liste sasiedztwa\n";
        cout<<"9 - tests\n";
        std::cin>>a;
        getchar();
        switch(a){
            case 1: {
                double counter;
                graph.TSP_prep();
                StartCounter(graph.getVortexAmount());
                graph.TSP();
                counter = GetCounter();
                cout << "Executed in: " << counter << " " << jednostka_czasu << "\n";
                graph.printTSP();
                getchar();
                break;
            }
            case 2: {
                double counter;
                graph.TSP_DP_prep();
                StartCounter(graph.getVortexAmount());
                graph.TSP_DP(0);
                counter = GetCounter();
                cout << "Executed in: " << counter << " " << jednostka_czasu << "\n";
                graph.printTSP();
                getchar();
                break;
            }
            case 3:{
                int b;
                cout<<"How many vortices?: \n";
                std::cin>>b;
                graph.addMultipleVortices(b);
            }
                break;

            case 4: {
                int b;
                cout << "Origin index?: \n";
                std::cin >> b;
                if (b < 0){
                    cout<<"Incorrect index\n"; break;
                }
                int c;
                cout << "Destination index?: \n";
                std::cin >> c;
                if (c > graph.getVortexAmount() - 1){
                    cout<<"Incorrect index\n"; break;
                }
                int d;
                cout << "Weight?: \n";
                std::cin >> d;
                graph.addEdge(Edge(b,c,d));
            }
                break;

            case 5:
                graph.fillGraphWithEdgesRandom();
                break;

            case 6:{
                std::string name;
                cout<<"Nazwa pliku: ";
                std::cin>>name;
                std::ifstream readfile(name);
                int amount;
                readfile>>amount;
                graph.addMultipleVortices(amount);
                for (int i = 0; i < amount; ++i) {
                    for (int j = 0; j < amount; ++j) {
                        int weight;
                        readfile>>weight;
                        if (i != j){
                            graph.addEdge({i,j,weight});
                        }
                    }
                }
                readfile.close();
            }
                break;

            case 7:
                system("cls");
                graph.printGraphMatrix();
                cout<<"Enter key!\n";
                getchar();
                break;

            case 8:
                system("cls");
                graph.printGraphList();
                cout<<"Enter key!\n";
                getchar();
                break;

            case 0:
                return;
                break;
            case 9:
                tests();
                break;

            default:
                cout<<"Wrong Input!\n";
                getchar();
                getchar();
                break;
        }
        system(("cls"));
    }
}
void createFile(int vortexAmount){
    std::ofstream file("graph.txt");
    file<<vortexAmount<<"\n";
    for (int i = 0; i < vortexAmount; ++i) {
        for (int j = 0; j < vortexAmount; ++j) {
            if (i == j) file<<-1<<"\t";
            else file<<distributionMain(generatorMain)<<"\t";
        }
        file<<"\n";
    }
    file.close();
}
void StartCounter(int n) {
    LARGE_INTEGER li;
    if (!QueryPerformanceFrequency(&li))
        cout << "QueryPerformanceFrequency failed!\n";
    if (n<=15){
        PCFreq = double(li.QuadPart) / 1000000.0; jednostka_czasu = "microseconds";//czas w mikrosekundach
    }
    else if (n<=20) {
        PCFreq = double(li.QuadPart)/1000.0;jednostka_czasu = "milliseconds";//czas w milisekundach
    }
    else {
        PCFreq = double(li.QuadPart);jednostka_czasu = "seconds";//czas w sekundach
    }
    QueryPerformanceCounter(&li);
    CounterStart = li.QuadPart;
}

double GetCounter() {
    LARGE_INTEGER li;
    QueryPerformanceCounter(&li);
    return double(li.QuadPart - CounterStart) / PCFreq;
}
void tests(){
    int vorticeAmount[7] = {5, 6, 7, 8, 11 , 12, 13};
    for (int lol : vorticeAmount){
        std::string name = "BF"; name += std::to_string(lol);   name +=".csv";
        std::ofstream file (name);
        for (int i = 0; i < 100; ++i) {
            Graph graphTest;
            double d;
            graphTest.addMultipleVortices(lol);
            graphTest.fillGraphWithEdgesRandom();
            graphTest.TSP_DP_prep();
            StartCounter(graphTest.getVortexAmount());
            graphTest.TSP_DP(0);
            d = GetCounter();
            cout<<"Vortices: " <<lol<<"| i = "<<i<<" | Time = "<<d<<"\n";
            file<<d<<";\n";
        }
    }
}